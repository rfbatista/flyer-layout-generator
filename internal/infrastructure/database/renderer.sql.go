// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: renderer.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRendererJob = `-- name: CreateRendererJob :one
INSERT INTO renderer_jobs (layout_id, adaptation_id)
VALUES 
  ($1, $2)
RETURNING id
`

type CreateRendererJobParams struct {
	LayoutID     pgtype.Int4 `json:"layout_id"`
	AdaptationID pgtype.Int4 `json:"adaptation_id"`
}

func (q *Queries) CreateRendererJob(ctx context.Context, arg CreateRendererJobParams) (int64, error) {
	row := q.db.QueryRow(ctx, createRendererJob, arg.LayoutID, arg.AdaptationID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listRendererJobs = `-- name: ListRendererJobs :many
SELECT id, layout_id, image_id, adaptation_id, status, attempts, started_at, finished_at, error_at, created_at, log 
FROM renderer_jobs
WHERE adaptation_id = $1 
AND (status <> $2 OR NOT $3)
`

type ListRendererJobsParams struct {
	AdaptationID   pgtype.Int4           `json:"adaptation_id"`
	Status         NullRendererJobStatus `json:"status"`
	FilterByStatus interface{}           `json:"filter_by_status"`
}

func (q *Queries) ListRendererJobs(ctx context.Context, arg ListRendererJobsParams) ([]RendererJob, error) {
	rows, err := q.db.Query(ctx, listRendererJobs, arg.AdaptationID, arg.Status, arg.FilterByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RendererJob
	for rows.Next() {
		var i RendererJob
		if err := rows.Scan(
			&i.ID,
			&i.LayoutID,
			&i.ImageID,
			&i.AdaptationID,
			&i.Status,
			&i.Attempts,
			&i.StartedAt,
			&i.FinishedAt,
			&i.ErrorAt,
			&i.CreatedAt,
			&i.Log,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRendererJob = `-- name: UpdateRendererJob :one
UPDATE renderer_jobs
SET 
    status = CASE WHEN $1::boolean
        THEN $2 ELSE status END,
    image_id = CASE WHEN $3::boolean
        THEN $4 ELSE image_id END,
    started_at = CASE WHEN $5::boolean
        THEN $6 ELSE started_at END,
    finished_at = CASE WHEN $7::boolean
        THEN $8 ELSE finished_at END,
    error_at = CASE WHEN $9::boolean
        THEN $10 ELSE error_at END,
    log = CASE WHEN $11::boolean
        THEN $12 ELSE log END,
    updated_at = NOW()
WHERE id = 1
RETURNING id, layout_id, image_id, adaptation_id, status, attempts, started_at, finished_at, error_at, created_at, log
`

type UpdateRendererJobParams struct {
	StatusDoUpdate     bool                  `json:"status_do_update"`
	Status             NullRendererJobStatus `json:"status"`
	ImageDoUpdate      bool                  `json:"image_do_update"`
	ImageID            pgtype.Int4           `json:"image_id"`
	StartedAtDoUpdate  bool                  `json:"started_at_do_update"`
	StartedAt          pgtype.Timestamp      `json:"started_at"`
	FinishedAtDoUpdate bool                  `json:"finished_at_do_update"`
	FinishedAt         pgtype.Timestamp      `json:"finished_at"`
	ErrorAtDoUpdate    bool                  `json:"error_at_do_update"`
	ErrorAt            pgtype.Timestamp      `json:"error_at"`
	LogDoUpdate        bool                  `json:"log_do_update"`
	Log                pgtype.Text           `json:"log"`
}

func (q *Queries) UpdateRendererJob(ctx context.Context, arg UpdateRendererJobParams) (RendererJob, error) {
	row := q.db.QueryRow(ctx, updateRendererJob,
		arg.StatusDoUpdate,
		arg.Status,
		arg.ImageDoUpdate,
		arg.ImageID,
		arg.StartedAtDoUpdate,
		arg.StartedAt,
		arg.FinishedAtDoUpdate,
		arg.FinishedAt,
		arg.ErrorAtDoUpdate,
		arg.ErrorAt,
		arg.LogDoUpdate,
		arg.Log,
	)
	var i RendererJob
	err := row.Scan(
		&i.ID,
		&i.LayoutID,
		&i.ImageID,
		&i.AdaptationID,
		&i.Status,
		&i.Attempts,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ErrorAt,
		&i.CreatedAt,
		&i.Log,
	)
	return i, err
}

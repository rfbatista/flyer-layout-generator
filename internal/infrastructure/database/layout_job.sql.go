// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: layout_job.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelLayoutJob = `-- name: CancelLayoutJob :many
UPDATE layout_jobs
SET
  status = 'canceled',
  updated_at = NOW()
WHERE status <> 'canceled'
AND (adaptation_batch_id = $1 OR NOT $2)
AND (replication_batch_id = $1 OR NOT $3)
RETURNING id, based_on_layout_id, created_layout_id, template_id, user_id, config, adaptation_batch_id, replication_batch_id, status, attempts, started_at, finished_at, error_at, updated_at, created_at, log
`

type CancelLayoutJobParams struct {
	AdaptationBatchID   pgtype.Int4 `json:"adaptation_batch_id"`
	FilterByAdaptation  interface{} `json:"filter_by_adaptation"`
	FilterByReplication interface{} `json:"filter_by_replication"`
}

func (q *Queries) CancelLayoutJob(ctx context.Context, arg CancelLayoutJobParams) ([]LayoutJob, error) {
	rows, err := q.db.Query(ctx, cancelLayoutJob, arg.AdaptationBatchID, arg.FilterByAdaptation, arg.FilterByReplication)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LayoutJob
	for rows.Next() {
		var i LayoutJob
		if err := rows.Scan(
			&i.ID,
			&i.BasedOnLayoutID,
			&i.CreatedLayoutID,
			&i.TemplateID,
			&i.UserID,
			&i.Config,
			&i.AdaptationBatchID,
			&i.ReplicationBatchID,
			&i.Status,
			&i.Attempts,
			&i.StartedAt,
			&i.FinishedAt,
			&i.ErrorAt,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Log,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createLayoutJob = `-- name: CreateLayoutJob :one
INSERT INTO layout_jobs (
    based_on_layout_id, status, user_id, template_id,
    started_at, finished_at, error_at, updated_at, config, log, adaptation_batch_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9,$10, $11
)
RETURNING id
`

type CreateLayoutJobParams struct {
	BasedOnLayoutID   pgtype.Int4      `json:"based_on_layout_id"`
	Status            LayoutJobStatus  `json:"status"`
	UserID            pgtype.Int4      `json:"user_id"`
	TemplateID        pgtype.Int4      `json:"template_id"`
	StartedAt         pgtype.Timestamp `json:"started_at"`
	FinishedAt        pgtype.Timestamp `json:"finished_at"`
	ErrorAt           pgtype.Timestamp `json:"error_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	Config            pgtype.Text      `json:"config"`
	Log               pgtype.Text      `json:"log"`
	AdaptationBatchID pgtype.Int4      `json:"adaptation_batch_id"`
}

func (q *Queries) CreateLayoutJob(ctx context.Context, arg CreateLayoutJobParams) (int64, error) {
	row := q.db.QueryRow(ctx, createLayoutJob,
		arg.BasedOnLayoutID,
		arg.Status,
		arg.UserID,
		arg.TemplateID,
		arg.StartedAt,
		arg.FinishedAt,
		arg.ErrorAt,
		arg.UpdatedAt,
		arg.Config,
		arg.Log,
		arg.AdaptationBatchID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getLayoutJobByID = `-- name: GetLayoutJobByID :one
SELECT id, based_on_layout_id, created_layout_id, template_id, user_id, config, adaptation_batch_id, replication_batch_id, status, attempts, started_at, finished_at, error_at, updated_at, created_at, log FROM layout_jobs WHERE id = $1
`

func (q *Queries) GetLayoutJobByID(ctx context.Context, id int64) (LayoutJob, error) {
	row := q.db.QueryRow(ctx, getLayoutJobByID, id)
	var i LayoutJob
	err := row.Scan(
		&i.ID,
		&i.BasedOnLayoutID,
		&i.CreatedLayoutID,
		&i.TemplateID,
		&i.UserID,
		&i.Config,
		&i.AdaptationBatchID,
		&i.ReplicationBatchID,
		&i.Status,
		&i.Attempts,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ErrorAt,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Log,
	)
	return i, err
}

const updateLayoutJob = `-- name: UpdateLayoutJob :one
UPDATE layout_jobs
SET 
    status = CASE WHEN $1::boolean
        THEN $2 ELSE status END,
    started_at = CASE WHEN $3::boolean
        THEN $4 ELSE started_at END,
    finished_at = CASE WHEN $5::boolean
        THEN $6 ELSE finished_at END,
    error_at = CASE WHEN $7::boolean
        THEN $8 ELSE error_at END,
    log = CASE WHEN $9::boolean
        THEN $10 ELSE log END,
    created_layout_id= CASE WHEN $11::boolean
        THEN $12 ELSE created_layout_id END,
    updated_at = NOW()
WHERE
    id = $13
RETURNING id, based_on_layout_id, created_layout_id, template_id, user_id, config, adaptation_batch_id, replication_batch_id, status, attempts, started_at, finished_at, error_at, updated_at, created_at, log
`

type UpdateLayoutJobParams struct {
	StatusDoUpdate        bool                `json:"status_do_update"`
	Status                NullLayoutJobStatus `json:"status"`
	StartedAtDoUpdate     bool                `json:"started_at_do_update"`
	StartedAt             pgtype.Timestamp    `json:"started_at"`
	FinishedAtDoUpdate    bool                `json:"finished_at_do_update"`
	FinishedAt            pgtype.Timestamp    `json:"finished_at"`
	ErrorAtDoUpdate       bool                `json:"error_at_do_update"`
	ErrorAt               pgtype.Timestamp    `json:"error_at"`
	LogDoUpdated          bool                `json:"log_do_updated"`
	Log                   pgtype.Text         `json:"log"`
	CreatedLayoutDoUpdate bool                `json:"created_layout_do_update"`
	CreatedLayoutID       pgtype.Int4         `json:"created_layout_id"`
	ID                    pgtype.Int8         `json:"id"`
}

func (q *Queries) UpdateLayoutJob(ctx context.Context, arg UpdateLayoutJobParams) (LayoutJob, error) {
	row := q.db.QueryRow(ctx, updateLayoutJob,
		arg.StatusDoUpdate,
		arg.Status,
		arg.StartedAtDoUpdate,
		arg.StartedAt,
		arg.FinishedAtDoUpdate,
		arg.FinishedAt,
		arg.ErrorAtDoUpdate,
		arg.ErrorAt,
		arg.LogDoUpdated,
		arg.Log,
		arg.CreatedLayoutDoUpdate,
		arg.CreatedLayoutID,
		arg.ID,
	)
	var i LayoutJob
	err := row.Scan(
		&i.ID,
		&i.BasedOnLayoutID,
		&i.CreatedLayoutID,
		&i.TemplateID,
		&i.UserID,
		&i.Config,
		&i.AdaptationBatchID,
		&i.ReplicationBatchID,
		&i.Status,
		&i.Attempts,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ErrorAt,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Log,
	)
	return i, err
}

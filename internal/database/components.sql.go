// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: components.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearEmptyComponents = `-- name: ClearEmptyComponents :exec
DELETE FROM design_components
WHERE NOT EXISTS (
    SELECT 1
    FROM design_element
    WHERE design_element.component_id = design_components.id
)
`

func (q *Queries) ClearEmptyComponents(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearEmptyComponents)
	return err
}

const createComponent = `-- name: CreateComponent :one
INSERT INTO design_components (
  design_id,
  width,
  height,
  xi,
  xii,
  yi,
  yii,
  type,
  color,
  bbox_xi,
  bbox_yi,
  bbox_xii,
  bbox_yii,
  inner_xi,
  inner_xii,
  inner_yi,
  inner_yii
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
)
RETURNING id, design_id, width, height, color, type, xi, xii, yi, yii, bbox_xi, bbox_xii, bbox_yi, bbox_yii, priority, inner_xi, inner_xii, inner_yi, inner_yii, created_at
`

type CreateComponentParams struct {
	DesignID int32             `json:"design_id"`
	Width    pgtype.Int4       `json:"width"`
	Height   pgtype.Int4       `json:"height"`
	Xi       pgtype.Int4       `json:"xi"`
	Xii      pgtype.Int4       `json:"xii"`
	Yi       pgtype.Int4       `json:"yi"`
	Yii      pgtype.Int4       `json:"yii"`
	Type     NullComponentType `json:"type"`
	Color    pgtype.Text       `json:"color"`
	BboxXi   pgtype.Int4       `json:"bbox_xi"`
	BboxYi   pgtype.Int4       `json:"bbox_yi"`
	BboxXii  pgtype.Int4       `json:"bbox_xii"`
	BboxYii  pgtype.Int4       `json:"bbox_yii"`
	InnerXi  pgtype.Int4       `json:"inner_xi"`
	InnerXii pgtype.Int4       `json:"inner_xii"`
	InnerYi  pgtype.Int4       `json:"inner_yi"`
	InnerYii pgtype.Int4       `json:"inner_yii"`
}

func (q *Queries) CreateComponent(ctx context.Context, arg CreateComponentParams) (DesignComponent, error) {
	row := q.db.QueryRow(ctx, createComponent,
		arg.DesignID,
		arg.Width,
		arg.Height,
		arg.Xi,
		arg.Xii,
		arg.Yi,
		arg.Yii,
		arg.Type,
		arg.Color,
		arg.BboxXi,
		arg.BboxYi,
		arg.BboxXii,
		arg.BboxYii,
		arg.InnerXi,
		arg.InnerXii,
		arg.InnerYi,
		arg.InnerYii,
	)
	var i DesignComponent
	err := row.Scan(
		&i.ID,
		&i.DesignID,
		&i.Width,
		&i.Height,
		&i.Color,
		&i.Type,
		&i.Xi,
		&i.Xii,
		&i.Yi,
		&i.Yii,
		&i.BboxXi,
		&i.BboxXii,
		&i.BboxYi,
		&i.BboxYii,
		&i.Priority,
		&i.InnerXi,
		&i.InnerXii,
		&i.InnerYi,
		&i.InnerYii,
		&i.CreatedAt,
	)
	return i, err
}

const getComponentByID = `-- name: GetComponentByID :one
select pc.id, pc.design_id, pc.width, pc.height, pc.color, pc.type, pc.xi, pc.xii, pc.yi, pc.yii, pc.bbox_xi, pc.bbox_xii, pc.bbox_yi, pc.bbox_yii, pc.priority, pc.inner_xi, pc.inner_xii, pc.inner_yi, pc.inner_yii, pc.created_at from design_components pc
where pc.id = $1 LIMIT 1
`

func (q *Queries) GetComponentByID(ctx context.Context, id int32) (DesignComponent, error) {
	row := q.db.QueryRow(ctx, getComponentByID, id)
	var i DesignComponent
	err := row.Scan(
		&i.ID,
		&i.DesignID,
		&i.Width,
		&i.Height,
		&i.Color,
		&i.Type,
		&i.Xi,
		&i.Xii,
		&i.Yi,
		&i.Yii,
		&i.BboxXi,
		&i.BboxXii,
		&i.BboxYi,
		&i.BboxYii,
		&i.Priority,
		&i.InnerXi,
		&i.InnerXii,
		&i.InnerYi,
		&i.InnerYii,
		&i.CreatedAt,
	)
	return i, err
}

const getComponentsByDesignID = `-- name: GetComponentsByDesignID :many
select pc.id, pc.design_id, pc.width, pc.height, pc.color, pc.type, pc.xi, pc.xii, pc.yi, pc.yii, pc.bbox_xi, pc.bbox_xii, pc.bbox_yi, pc.bbox_yii, pc.priority, pc.inner_xi, pc.inner_xii, pc.inner_yi, pc.inner_yii, pc.created_at from design_components pc
where pc.design_id = $1
`

func (q *Queries) GetComponentsByDesignID(ctx context.Context, designID int32) ([]DesignComponent, error) {
	rows, err := q.db.Query(ctx, getComponentsByDesignID, designID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DesignComponent
	for rows.Next() {
		var i DesignComponent
		if err := rows.Scan(
			&i.ID,
			&i.DesignID,
			&i.Width,
			&i.Height,
			&i.Color,
			&i.Type,
			&i.Xi,
			&i.Xii,
			&i.Yi,
			&i.Yii,
			&i.BboxXi,
			&i.BboxXii,
			&i.BboxYi,
			&i.BboxYii,
			&i.Priority,
			&i.InnerXi,
			&i.InnerXii,
			&i.InnerYi,
			&i.InnerYii,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const haveElementsIn = `-- name: HaveElementsIn :many
select pc.id, pc.design_id, pc.width, pc.height, pc.color, pc.type, pc.xi, pc.xii, pc.yi, pc.yii, pc.bbox_xi, pc.bbox_xii, pc.bbox_yi, pc.bbox_yii, pc.priority, pc.inner_xi, pc.inner_xii, pc.inner_yi, pc.inner_yii, pc.created_at from design_components pc
inner join design_element as pe on pe.component_id = pc.id 
where pc.id = $1
`

func (q *Queries) HaveElementsIn(ctx context.Context, id int32) ([]DesignComponent, error) {
	rows, err := q.db.Query(ctx, haveElementsIn, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DesignComponent
	for rows.Next() {
		var i DesignComponent
		if err := rows.Scan(
			&i.ID,
			&i.DesignID,
			&i.Width,
			&i.Height,
			&i.Color,
			&i.Type,
			&i.Xi,
			&i.Xii,
			&i.Yi,
			&i.Yii,
			&i.BboxXi,
			&i.BboxXii,
			&i.BboxYi,
			&i.BboxYii,
			&i.Priority,
			&i.InnerXi,
			&i.InnerXii,
			&i.InnerYi,
			&i.InnerYii,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeComponentFromElements = `-- name: RemoveComponentFromElements :many
UPDATE design_element
SET 
    component_id = NULL
WHERE
    id = ANY ($1) and design_id = $2
RETURNING id, design_id, name, layer_id, text, xi, xii, yi, yii, inner_xi, inner_xii, inner_yi, inner_yii, width, height, is_group, group_id, level, kind, component_id, image_url, image_extension, created_at, updated_at
`

type RemoveComponentFromElementsParams struct {
	Ids      []int32 `json:"ids"`
	DesignID int32   `json:"design_id"`
}

func (q *Queries) RemoveComponentFromElements(ctx context.Context, arg RemoveComponentFromElementsParams) ([]DesignElement, error) {
	rows, err := q.db.Query(ctx, removeComponentFromElements, arg.Ids, arg.DesignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DesignElement
	for rows.Next() {
		var i DesignElement
		if err := rows.Scan(
			&i.ID,
			&i.DesignID,
			&i.Name,
			&i.LayerID,
			&i.Text,
			&i.Xi,
			&i.Xii,
			&i.Yi,
			&i.Yii,
			&i.InnerXi,
			&i.InnerXii,
			&i.InnerYi,
			&i.InnerYii,
			&i.Width,
			&i.Height,
			&i.IsGroup,
			&i.GroupID,
			&i.Level,
			&i.Kind,
			&i.ComponentID,
			&i.ImageUrl,
			&i.ImageExtension,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateManydesignElement = `-- name: UpdateManydesignElement :many
UPDATE design_element
SET 
    component_id = CASE WHEN $1::boolean
        THEN $2::int ELSE component_id END,

    name = CASE WHEN $3::boolean
        THEN $4 ELSE name END
WHERE
    id = ANY ($5) and design_id = $6
RETURNING id, design_id, name, layer_id, text, xi, xii, yi, yii, inner_xi, inner_xii, inner_yi, inner_yii, width, height, is_group, group_id, level, kind, component_id, image_url, image_extension, created_at, updated_at
`

type UpdateManydesignElementParams struct {
	ComponentIDDoUpdate bool        `json:"component_id_do_update"`
	ComponentID         int32       `json:"component_id"`
	NameDoUpdate        bool        `json:"name_do_update"`
	Name                pgtype.Text `json:"name"`
	Ids                 []int32     `json:"ids"`
	DesignID            int32       `json:"design_id"`
}

// You can use sqlc.arg() and @ to identify named parameters
func (q *Queries) UpdateManydesignElement(ctx context.Context, arg UpdateManydesignElementParams) ([]DesignElement, error) {
	rows, err := q.db.Query(ctx, updateManydesignElement,
		arg.ComponentIDDoUpdate,
		arg.ComponentID,
		arg.NameDoUpdate,
		arg.Name,
		arg.Ids,
		arg.DesignID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DesignElement
	for rows.Next() {
		var i DesignElement
		if err := rows.Scan(
			&i.ID,
			&i.DesignID,
			&i.Name,
			&i.LayerID,
			&i.Text,
			&i.Xi,
			&i.Xii,
			&i.Yi,
			&i.Yii,
			&i.InnerXi,
			&i.InnerXii,
			&i.InnerYi,
			&i.InnerYii,
			&i.Width,
			&i.Height,
			&i.IsGroup,
			&i.GroupID,
			&i.Level,
			&i.Kind,
			&i.ComponentID,
			&i.ImageUrl,
			&i.ImageExtension,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

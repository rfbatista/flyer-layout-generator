// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: components.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComponent = `-- name: CreateComponent :one
INSERT INTO photoshop_components (
  photoshop_id,
  width,
  height,
  xi,
  xii,
  yi,
  yii,
  type,
  color
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, photoshop_id, width, height, color, type, xi, xii, yi, yii, created_at
`

type CreateComponentParams struct {
	PhotoshopID int32             `json:"photoshop_id"`
	Width       pgtype.Int4       `json:"width"`
	Height      pgtype.Int4       `json:"height"`
	Xi          pgtype.Int4       `json:"xi"`
	Xii         pgtype.Int4       `json:"xii"`
	Yi          pgtype.Int4       `json:"yi"`
	Yii         pgtype.Int4       `json:"yii"`
	Type        NullComponentType `json:"type"`
	Color       pgtype.Text       `json:"color"`
}

func (q *Queries) CreateComponent(ctx context.Context, arg CreateComponentParams) (PhotoshopComponent, error) {
	row := q.db.QueryRow(ctx, createComponent,
		arg.PhotoshopID,
		arg.Width,
		arg.Height,
		arg.Xi,
		arg.Xii,
		arg.Yi,
		arg.Yii,
		arg.Type,
		arg.Color,
	)
	var i PhotoshopComponent
	err := row.Scan(
		&i.ID,
		&i.PhotoshopID,
		&i.Width,
		&i.Height,
		&i.Color,
		&i.Type,
		&i.Xi,
		&i.Xii,
		&i.Yi,
		&i.Yii,
		&i.CreatedAt,
	)
	return i, err
}

const getComponentByID = `-- name: GetComponentByID :one
select pc.id, pc.photoshop_id, pc.width, pc.height, pc.color, pc.type, pc.xi, pc.xii, pc.yi, pc.yii, pc.created_at from photoshop_components pc
where pc.id = $1 LIMIT 1
`

func (q *Queries) GetComponentByID(ctx context.Context, id int32) (PhotoshopComponent, error) {
	row := q.db.QueryRow(ctx, getComponentByID, id)
	var i PhotoshopComponent
	err := row.Scan(
		&i.ID,
		&i.PhotoshopID,
		&i.Width,
		&i.Height,
		&i.Color,
		&i.Type,
		&i.Xi,
		&i.Xii,
		&i.Yi,
		&i.Yii,
		&i.CreatedAt,
	)
	return i, err
}

const haveElementsIn = `-- name: HaveElementsIn :many
select pc.id, pc.photoshop_id, pc.width, pc.height, pc.color, pc.type, pc.xi, pc.xii, pc.yi, pc.yii, pc.created_at from photoshop_components pc
inner join photoshop_element as pe on pe.component_id = pc.id 
where pc.id = $1
`

func (q *Queries) HaveElementsIn(ctx context.Context, id int32) ([]PhotoshopComponent, error) {
	rows, err := q.db.Query(ctx, haveElementsIn, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PhotoshopComponent
	for rows.Next() {
		var i PhotoshopComponent
		if err := rows.Scan(
			&i.ID,
			&i.PhotoshopID,
			&i.Width,
			&i.Height,
			&i.Color,
			&i.Type,
			&i.Xi,
			&i.Xii,
			&i.Yi,
			&i.Yii,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listComponentByFileId = `-- name: ListComponentByFileId :many
select pc.id, pc.photoshop_id, pc.width, pc.height, pc.color, pc.type, pc.xi, pc.xii, pc.yi, pc.yii, pc.created_at from photoshop_components pc
where pc.photoshop_id = $1
`

func (q *Queries) ListComponentByFileId(ctx context.Context, photoshopID int32) ([]PhotoshopComponent, error) {
	rows, err := q.db.Query(ctx, listComponentByFileId, photoshopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PhotoshopComponent
	for rows.Next() {
		var i PhotoshopComponent
		if err := rows.Scan(
			&i.ID,
			&i.PhotoshopID,
			&i.Width,
			&i.Height,
			&i.Color,
			&i.Type,
			&i.Xi,
			&i.Xii,
			&i.Yi,
			&i.Yii,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeComponentFromElements = `-- name: RemoveComponentFromElements :many
UPDATE photoshop_element
SET 
    component_id = NULL
WHERE
    id = ANY ($1) and photoshop_id = $2
RETURNING id, photoshop_id, name, layer_id, text, xi, xii, yi, yii, width, height, is_group, group_id, level, kind, component_id, image_url, image_extension, created_at, updated_at
`

type RemoveComponentFromElementsParams struct {
	Ids         []int32 `json:"ids"`
	PhotoshopID int32   `json:"photoshop_id"`
}

func (q *Queries) RemoveComponentFromElements(ctx context.Context, arg RemoveComponentFromElementsParams) ([]PhotoshopElement, error) {
	rows, err := q.db.Query(ctx, removeComponentFromElements, arg.Ids, arg.PhotoshopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PhotoshopElement
	for rows.Next() {
		var i PhotoshopElement
		if err := rows.Scan(
			&i.ID,
			&i.PhotoshopID,
			&i.Name,
			&i.LayerID,
			&i.Text,
			&i.Xi,
			&i.Xii,
			&i.Yi,
			&i.Yii,
			&i.Width,
			&i.Height,
			&i.IsGroup,
			&i.GroupID,
			&i.Level,
			&i.Kind,
			&i.ComponentID,
			&i.ImageUrl,
			&i.ImageExtension,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateManyPhotoshopElement = `-- name: UpdateManyPhotoshopElement :many
UPDATE photoshop_element
SET 
    component_id = CASE WHEN $1::boolean
        THEN $2::int ELSE component_id END,

    name = CASE WHEN $3::boolean
        THEN $4 ELSE name END
WHERE
    id = ANY ($5) and photoshop_id = $6
RETURNING id, photoshop_id, name, layer_id, text, xi, xii, yi, yii, width, height, is_group, group_id, level, kind, component_id, image_url, image_extension, created_at, updated_at
`

type UpdateManyPhotoshopElementParams struct {
	ComponentIDDoUpdate bool        `json:"component_id_do_update"`
	ComponentID         int32       `json:"component_id"`
	NameDoUpdate        bool        `json:"name_do_update"`
	Name                pgtype.Text `json:"name"`
	Ids                 []int32     `json:"ids"`
	PhotoshopID         int32       `json:"photoshop_id"`
}

// You can use sqlc.arg() and @ to identify named parameters
func (q *Queries) UpdateManyPhotoshopElement(ctx context.Context, arg UpdateManyPhotoshopElementParams) ([]PhotoshopElement, error) {
	rows, err := q.db.Query(ctx, updateManyPhotoshopElement,
		arg.ComponentIDDoUpdate,
		arg.ComponentID,
		arg.NameDoUpdate,
		arg.Name,
		arg.Ids,
		arg.PhotoshopID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PhotoshopElement
	for rows.Next() {
		var i PhotoshopElement
		if err := rows.Scan(
			&i.ID,
			&i.PhotoshopID,
			&i.Name,
			&i.LayerID,
			&i.Text,
			&i.Xi,
			&i.Xii,
			&i.Yi,
			&i.Yii,
			&i.Width,
			&i.Height,
			&i.IsGroup,
			&i.GroupID,
			&i.Level,
			&i.Kind,
			&i.ComponentID,
			&i.ImageUrl,
			&i.ImageExtension,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

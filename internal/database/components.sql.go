// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: components.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComponent = `-- name: CreateComponent :one
INSERT INTO design_components (
  design_id,
  width,
  height,
  xi,
  xii,
  yi,
  yii,
  type,
  color
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, design_id, width, height, color, type, xi, xii, yi, yii, created_at
`

type CreateComponentParams struct {
	DesignID int32             `json:"design_id"`
	Width    pgtype.Int4       `json:"width"`
	Height   pgtype.Int4       `json:"height"`
	Xi       pgtype.Int4       `json:"xi"`
	Xii      pgtype.Int4       `json:"xii"`
	Yi       pgtype.Int4       `json:"yi"`
	Yii      pgtype.Int4       `json:"yii"`
	Type     NullComponentType `json:"type"`
	Color    pgtype.Text       `json:"color"`
}

func (q *Queries) CreateComponent(ctx context.Context, arg CreateComponentParams) (DesignComponent, error) {
	row := q.db.QueryRow(ctx, createComponent,
		arg.DesignID,
		arg.Width,
		arg.Height,
		arg.Xi,
		arg.Xii,
		arg.Yi,
		arg.Yii,
		arg.Type,
		arg.Color,
	)
	var i DesignComponent
	err := row.Scan(
		&i.ID,
		&i.DesignID,
		&i.Width,
		&i.Height,
		&i.Color,
		&i.Type,
		&i.Xi,
		&i.Xii,
		&i.Yi,
		&i.Yii,
		&i.CreatedAt,
	)
	return i, err
}

const getComponentByID = `-- name: GetComponentByID :one
select pc.id, pc.design_id, pc.width, pc.height, pc.color, pc.type, pc.xi, pc.xii, pc.yi, pc.yii, pc.created_at from design_components pc
where pc.id = $1 LIMIT 1
`

func (q *Queries) GetComponentByID(ctx context.Context, id int32) (DesignComponent, error) {
	row := q.db.QueryRow(ctx, getComponentByID, id)
	var i DesignComponent
	err := row.Scan(
		&i.ID,
		&i.DesignID,
		&i.Width,
		&i.Height,
		&i.Color,
		&i.Type,
		&i.Xi,
		&i.Xii,
		&i.Yi,
		&i.Yii,
		&i.CreatedAt,
	)
	return i, err
}

const haveElementsIn = `-- name: HaveElementsIn :many
select pc.id, pc.design_id, pc.width, pc.height, pc.color, pc.type, pc.xi, pc.xii, pc.yi, pc.yii, pc.created_at from design_components pc
inner join design_element as pe on pe.component_id = pc.id 
where pc.id = $1
`

func (q *Queries) HaveElementsIn(ctx context.Context, id int32) ([]DesignComponent, error) {
	rows, err := q.db.Query(ctx, haveElementsIn, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DesignComponent
	for rows.Next() {
		var i DesignComponent
		if err := rows.Scan(
			&i.ID,
			&i.DesignID,
			&i.Width,
			&i.Height,
			&i.Color,
			&i.Type,
			&i.Xi,
			&i.Xii,
			&i.Yi,
			&i.Yii,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listComponentByFileId = `-- name: ListComponentByFileId :many
select pc.id, pc.design_id, pc.width, pc.height, pc.color, pc.type, pc.xi, pc.xii, pc.yi, pc.yii, pc.created_at from design_components pc
where pc.design_id = $1
`

func (q *Queries) ListComponentByFileId(ctx context.Context, designID int32) ([]DesignComponent, error) {
	rows, err := q.db.Query(ctx, listComponentByFileId, designID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DesignComponent
	for rows.Next() {
		var i DesignComponent
		if err := rows.Scan(
			&i.ID,
			&i.DesignID,
			&i.Width,
			&i.Height,
			&i.Color,
			&i.Type,
			&i.Xi,
			&i.Xii,
			&i.Yi,
			&i.Yii,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeComponentFromElements = `-- name: RemoveComponentFromElements :many
UPDATE design_element
SET 
    component_id = NULL
WHERE
    id = ANY ($1) and design_id = $2
RETURNING id, design_id, name, layer_id, text, xi, xii, yi, yii, width, height, is_group, group_id, level, kind, component_id, image_url, image_extension, created_at, updated_at
`

type RemoveComponentFromElementsParams struct {
	Ids      []int32 `json:"ids"`
	DesignID int32   `json:"design_id"`
}

func (q *Queries) RemoveComponentFromElements(ctx context.Context, arg RemoveComponentFromElementsParams) ([]DesignElement, error) {
	rows, err := q.db.Query(ctx, removeComponentFromElements, arg.Ids, arg.DesignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DesignElement
	for rows.Next() {
		var i DesignElement
		if err := rows.Scan(
			&i.ID,
			&i.DesignID,
			&i.Name,
			&i.LayerID,
			&i.Text,
			&i.Xi,
			&i.Xii,
			&i.Yi,
			&i.Yii,
			&i.Width,
			&i.Height,
			&i.IsGroup,
			&i.GroupID,
			&i.Level,
			&i.Kind,
			&i.ComponentID,
			&i.ImageUrl,
			&i.ImageExtension,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateManydesignElement = `-- name: UpdateManydesignElement :many
UPDATE design_element
SET 
    component_id = CASE WHEN $1::boolean
        THEN $2::int ELSE component_id END,

    name = CASE WHEN $3::boolean
        THEN $4 ELSE name END
WHERE
    id = ANY ($5) and design_id = $6
RETURNING id, design_id, name, layer_id, text, xi, xii, yi, yii, width, height, is_group, group_id, level, kind, component_id, image_url, image_extension, created_at, updated_at
`

type UpdateManydesignElementParams struct {
	ComponentIDDoUpdate bool        `json:"component_id_do_update"`
	ComponentID         int32       `json:"component_id"`
	NameDoUpdate        bool        `json:"name_do_update"`
	Name                pgtype.Text `json:"name"`
	Ids                 []int32     `json:"ids"`
	DesignID            int32       `json:"design_id"`
}

// You can use sqlc.arg() and @ to identify named parameters
func (q *Queries) UpdateManydesignElement(ctx context.Context, arg UpdateManydesignElementParams) ([]DesignElement, error) {
	rows, err := q.db.Query(ctx, updateManydesignElement,
		arg.ComponentIDDoUpdate,
		arg.ComponentID,
		arg.NameDoUpdate,
		arg.Name,
		arg.Ids,
		arg.DesignID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DesignElement
	for rows.Next() {
		var i DesignElement
		if err := rows.Scan(
			&i.ID,
			&i.DesignID,
			&i.Name,
			&i.LayerID,
			&i.Text,
			&i.Xi,
			&i.Xii,
			&i.Yi,
			&i.Yii,
			&i.Width,
			&i.Height,
			&i.IsGroup,
			&i.GroupID,
			&i.Level,
			&i.Kind,
			&i.ComponentID,
			&i.ImageUrl,
			&i.ImageExtension,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
